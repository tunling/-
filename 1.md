# 基础问题：
+	虚函数底层实现
    + 概述<br>
        虚函数表。编译器为每一个类对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针——虚表指针（vptr），这种数组为虚函数表（vtbl）。即每个类使用一个虚函数表，每个类对象用一个虚表指针。
    + 虚函数表构造过程<br>
        拷贝基类虚函数表-->替换已重写虚函数指针-->追加子类自己的虚函数指针。
+	父函数中调用虚函数
    + 简述<br>
        如果在父类函数中调用父类的虚函数，且该虚函数在子类中被改写了，那么在把子类指针/引用交给父类指针/引用的时候，再调用父类中的函数，该函数内的虚函数实际上是子类中改写过的。
+	父类、子类（构造、析构顺序）
    + 简述<br>
        构造时先调用父类构造函数再调用子类构造函数；<br>析构时相反，先调用子类析构函数再调用父类析构函数。
+	new、delete和malloc、free区别
    + new和delete的用法
        ```cpp
        //new
        int *pi=new int;
        int *pi=new int();
        int *pi=new int(1024);
        //delete
        delete pi;
        ```
    + malloc和free的用法
        ```c
        //malloc
        int *p=(int *)malloc(100);
        int *p=(int *)malloc(25*sizeof(int));
        //free
        free(p);
        ```
    + 区别
        + 属性<br>
            new和delete是C++关键字，需要编译器支持；<br>malloc和free是库函数，需要头文件支持。
        + 参数<br>
            使用new申请内存分配时无需指定内存块大小，编译器会根据类型信息自动计算；<br>malloc需要显式指定内存块大小。
        + 返回类型<br>
            new内存分配成功时返回对象类型的指针，无需进行类型转换，故new是符合类型安全性的操作符；<br>malloc内存分配成功返回(void *)，需要通过强制类型转换。
        + 分配失败<br>
            new内存分配失败时，会抛出bac_alloc异常；<br>malloc分配内存失败时返回NULL。
        + 自定义类型<br>
            new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现），然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针，delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。
        + 重载<br>
            C++允许重载new/delete操作符（如：布局new，指定一个地址作为内存起始区域，在这段内存上为对象调用构造函数完成初始化工作，并返回此地址）；<br>malloc不允许重载。
            ```cpp
            //布局new，注：此时不能对p进行释放空间
            char buffer[1024];
            char *p = new (buffer) char[sizeof(buffer)];
            ```
        + 内存区域<br>
            new操作符从自由存储区（free store）上为对象动态分配内存空间；<br>malloc函数从堆上动态分配内存。<br>（在C++中，内存区分为5个区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区；在C中，C内存区分为堆、栈、全局/静态存储区、常量存储区）

+	map的底层实现
    + 简述<br>
        map提供了排序功能，红黑树存储的键值是有序的，同时红黑树可以在O(log n)时间内做插入、查找和删除操作。在C++中unordered_map的底层使用哈希表实现，查找复效率不稳定。
+	hash表如何做（数据结构、算法、复杂度）
+	霍夫曼树的原理
+	平衡二叉树的旋转细节（举出一例）
+	若干个乱序数找出中位数（不使用排序，方法越优越好）
+	物理内存和虚拟内存的区别
+	进程间通信
+	死锁
+	内核态和用户态的区别
+	TCP为何三次握手四次挥手
+	TCP的拥塞控制和流量控制
+	socket是否阻塞态
+	输入url全过程
+	数据库何时用索引
+	数据库为何使用B+树

# 项目问题：
+	OpenMP底层实现
+   使用OpenMP对项目做了怎样的优化
+	关闭窗口确认时，无法点击窗体内容，如何做
+	用过哪些设计模式
+	是否使用过调试工具、性能分析工具，有哪些

# 现场编程题：
+	I am hero -> hero am I
+	二叉树的深度搜索和广度搜索

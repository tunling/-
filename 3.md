# 基础题
+   面向对象的三大特征，五大基本原则
    +   三大基本特征
        +   封装<br>
            隐藏对象的属性和实现细节，仅对外公开接口，目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，以特定的访问权限来使用类的成员。
        +   继承<br>
            继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。
        +   多态<br>
            同一个行为具有多个不同表现形式或形态的能力
    +   五大基本原则
        +   第一职责原则（SRP）<br>
            一个类应该有且只有一个去改变它的理由，这意味着一个类应该只有一项工作。
        +   开放封闭原则（OCP）<br>
            对象或实体应该对扩展开放，对修改封闭。
        +   里氏替换原则（LSP）<br>
            在对象 x 为类型 T 时 q(x) 成立，那么当 S 是 T 的子类时，对象 y 为类型 S 时 q(y) 也应成立。（即对父类的调用同样适用于子类）
        +   依赖倒置原则（DIP）<br>
            高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。具体实现应该依赖于抽象，而不是抽象依赖于实现。
        +   接口隔离原则（ISP）<br>
            不应强迫客户端实现一个它用不上的接口，或是说客户端不应该被迫依赖它们不使用的方法，使用多个专门的接口比使用单个接口要好的多！
+   C++的多态
    +   简述<br>
        C++的多态性是通过虚函数来实现的。
+   智能指针
    +   简述<br>
        智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。有五2种智能指针：shared_ptr，unique_ptr，auto_ptr，weak_ptr，scoped_ptr。
    +   share_ptr<br>
        允许多个指针指向同一个对象。
        ```cpp
        shared_ptr<int> p = make_shared<int>(42);   //创建shared_ptr
        p.unique()  // 若p.use_count()为1，返回true，否则返回false
        p.use_count()   // 返回与p共享对象的智能指针数量（用于调试）
        ```
    +   unique_ptr<br>
        某个时刻只能有一个unique_ptr指向一个给定对象，由于一个unique_ptr拥有它指向的对象，因此unique_ptr不支持普通的拷贝或赋值操作。
    +   auto_ptr<br>
        标准库的较早版本包含了一个名为auto_ptr的类，它具有uniqued_ptr的部分特性，但不是全部。<br>
        部分区别：auto_ptr支持拷贝构造与赋值操作，但unique_ptr不直接支持；unique_ptr可以用在函数返回值中；unique_ptr可做为容器元素。
    +   weak_ptr<br>
        weak_ptr是一种不控制所指向对象生存期的智能指针，它指向一个由shared_ptr管理的对象，将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放，即使有weak_ptr指向对象，对象还是会被释放。
    +   scoped_ptr<br>
        scoped和weak_ptr的区别就是，给出了拷贝和赋值操作的声明并没有给出具体实现，并且将这两个操作定义成私有的，这样就保证scoped_ptr不能使用拷贝来构造新的对象也不能执行赋值操作，更加安全，但有了"++""–"以及"*""->"这些操作，比weak_ptr能实现更多功能。
+   STL容器及其底层
    +   vector（连续的线性空间）
    +   queue（底层为deque）
    +   stack（底层默认为双端队列deque）
    +   list（底层为双向链表）
    +   forward_list（底层为单向链表）
    +   priority_queue（底层默认为大根堆）<br>
       小根堆声明方式priority_queue<int, vector<int>, greater<int> >q。
    +   deque（分段的线性空间）<br> 
        由一段一段等长的连续空间构成，各段空间之间并不一定是连续的，可以位于在内存的不同区域。<br>
        支持使用下标访问。  
    +   pair（结构体，first、second）
    +   map（红黑树）
    +   set（红黑树）
    +   multiset（红黑树）
    +   unordered_map（哈希表）
    +   bitset<br>
    用于装01串，可以使用下标访问。
    ```cpp
    bitset<100000> s;   //声明一个105位的bitset
    s.set();    //将bitset全部置为1
    s.set(u,v); //把bitset中的第u位变成v,v∈0/1。
    s.reset();  //将bitset的所有位置为0
    s.reset(k); //把这一位改成0。
    ```
+   dynamic_cast
    +   简述<br>
    dynamic_cast可以将一个基类对象指针（或引用）转换到继承类指针，dynamic_cast会根据基类指针是否真正指向继承类指针来做相应处理。（用于多态）
+   堆和栈(堆只能动态分配)
+   #define A(x) x+x    int i = 5*A(4)*A(6) // i=50
+   const int& a;   // 错误，引用需要初始化
+   5 | 7   // 7
# 编程题
+   密码判断
    1. 字符大于8
    2. 大小写，数字，其他（三种或以上）
    3. 不能有相同长度大于2的重复子串
+   string大于、小于、等于
+   水仙花数
+   约瑟夫环
+   动态规划走格子，只能向上或者向下走，求左上角到右下角的最大和。
+   最短路径（Dij，输出路径）